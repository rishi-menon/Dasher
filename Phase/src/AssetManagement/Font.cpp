#include "Font.h"
#include "Log.h"
#include "Texture.h"

#include <ft2build.h>
#include FT_FREETYPE_H  

FT_Library freeTypeLib;

bool FontInit()
{
	if (FT_Init_FreeType(&freeTypeLib))
	{
		ASSERT(false, "");
		LOG_CLIENT_ERROR("Could not initialise Freetype library");
		return false;
	}
	return true;
}
void FontCleanUp()
{
	FT_Done_FreeType(freeTypeLib);
}

FontCharacter::FontCharacter(unsigned int tex, const glm::ivec2& size, const glm::ivec2& bearing, unsigned int advance) :
	texId(tex), size(size), bearing (bearing), advance (advance)

{

}
bool Font::LoadFont(const char* path, unsigned int height)
{
	if (m_vCharacters.size())
	{
		LOG_WARN("Font was alraedy loaded");
		return false;
	}

#ifdef RM_MAC
	std::string strFullPath = g_strCurrentDirectory + path;
	path = strFullPath.c_str();
#endif

	m_vCharacters.reserve(128);
	m_vCharacters.clear();

	FT_Face face;
	if (FT_New_Face(freeTypeLib, path, 0, &face))
	{
		ASSERT(false, "Could not create a font face");
		return false;
	}
	FT_Set_Pixel_Sizes(face, 0, height);

	std::vector<unsigned char> buffer;

	//Start loading font characters
	for (unsigned char c = 0; c < 128; c++)
	{
		if (FT_Load_Char(face, c, FT_LOAD_RENDER))
		{
			ASSERT(false, "Could not load character: {0} ({1})", c, static_cast<int>(c));
			return false;
		}
		unsigned int width = face->glyph->bitmap.width;
		unsigned int rows = face->glyph->bitmap.rows;
		std::size_t index = 3;

		std::size_t totalLength = width * rows * 4;
		buffer.reserve(totalLength);
		buffer.clear();
		for (std::size_t i = 0; i < totalLength; i++)
		{
			buffer.emplace_back(255);
		}
		
		unsigned char* originalBuffer = face->glyph->bitmap.buffer;
		for (unsigned int i = 0; i < rows; i++)
		{
			for (unsigned int j = 0 ; j < width; j++)
			{
				//The bitmap generated by the freetyp is flipped vertically... The (rows-i-1) is reading it backwards which causes it to be in the right orientation
				buffer[index] = originalBuffer[(rows - i - 1) * width + j];
				index += 4;
			}
		}

		unsigned int texId = Texture::LoadTextureBuffer(buffer.data(), face->glyph->bitmap.width, face->glyph->bitmap.rows);
		glm::ivec2 size = { width, rows };
		glm::ivec2 bearing = {face->glyph->bitmap_left, face->glyph->bitmap_top};
		//Advance is stored as 1/64th of a pixel so divide the value by 64 to get pixels
		unsigned int advance = (face->glyph->advance.x >> 6);
		m_vCharacters.emplace_back(texId, size, bearing, advance);
	}	

	if (FT_Done_Face(face))
	{
		LOG_ERROR("Could not free font face");
	}
	return true;
}

void Font::Cleanup()
{
	for (std::size_t i = 0; i < m_vCharacters.size(); i++)
	{
		Texture::DeleteTexture (m_vCharacters[i].texId);
	}
	m_vCharacters.clear();
}